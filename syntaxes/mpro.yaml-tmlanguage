name: Mindustry Program
fileTypes: [ mpro ]
scopeName: source.mpro
foldingStartMarker: /\*\*|\{\s*$
foldingStopMarker: \*\*/|^\s*\}
patterns:
- include: '#comments'
- match: \b(break|continue|do|else|for|if|return|while)\b
  name: keyword.control.mpro
- include: '#constants'
- include: '#opeartors'
- include: '#numbers'
- include: '#strings'

- name: punctuation.terminator.statement.mpro
  match: \;
- name: meta.delimiter.object.comma.mpro
  match: ',[ |\t]*'
- name: meta.dot.mpro
  match: '\.(?![0-9])'

# Blocks of {}, [], ()
- include: '#brace_block'
- include: '#bracket_block'
- include: '#paren_block'

#################################################################
# Incorporated from PythonImproved grammar

# Function definition
- name: meta.function.mpro
  begin: \b(function)\s+(?=[[:alpha:]_][[:alnum:]_]*)\s*(?=\()
  beginCaptures:
    '1': {name: storage.type.function.mpro}
    # Add invalid name
  end: (?<=\))
  endCaptures:
    '1': {name: punctuation.definition.parameters.begin.mpro}
  patterns:
  - contentName: entity.name.function.mpro
    begin: (?=[[:alpha:]_][[:alnum:]_]*)
    end: (?![[:alnum:]_])
    patterns:
    - include: '#illegal_names'
    # - include: '#entity_name_function'
  - contentName: meta.function.parameters.mpro
    begin: (\()
    beginCaptures:
      '1': {name: punctuation.definition.parameters.begin.mpro}
    end: (?=\))
    patterns:
    # - include: '#annotated_arguments'
    - include: '#keyword_arguments'
    - include: '#illegal_names'
    # - include: '#comments'
    - match: \b(?:([[:alpha:]_][[:alnum:]_]*))\s*(?:(,)|(?=[\n\)]))
      captures:
        '1': {name: variable.parameter.function.language.mpro}
        '2': {name: punctuation.separator.parameters.mpro}
        '3': {name: punctuation.separator.parameters.mpro}
  - begin: (\))
    beginCaptures:
      '1': {name: punctuation.definition.parameters.end.mpro}
    end: (?<=\))
    patterns:
    - include: $self

# After main function decleration to catch stray module / funciton
- match: '\bfunction\b'
  name: storage.type.function.mpro

# Function call (does not start with 'module' or 'function' but may have a dot separator)
- name: meta.function-call.mpro
  begin: (?:\.)?([[:alpha:]_][[:alnum:]_]*)\s*(?=(\())
  beginCaptures:
    # NOTE: Should also probably have map: 'meta.function-call.generic.mpro'
    #       but opted for 'entity.name.function.call.mpro' for coloring purposes
    '1': {name: entity.name.function.call.mpro}
    '2': {name: punctuation.definition.arguments.begin.mpro}
  end: (\))
  endCaptures:
    '1': {name: punctuation.definition.arguments.end.mpro}
  patterns:
  - contentName: meta.function-call.arguments.mpro
    begin: (\()
    beginCaptures:
      '1': {name: punctuation.definition.arguments.begin.mpro}
    end: (?=(\)))
    endCaptures:
      '1': {name: punctuation.definition.arguments.end.mpro}
    patterns:
    - include: '#keyword_arguments'
    - include: $self
#################################################################

- include: '#function_builtin'

repository:
  brace_block:
    name: meta.block.mpro
    begin: '\{'
    end: '\}'
    beginCaptures:
      '0': {name: punctuation.section.block.begin.bracket.curly.mpro}
    endCaptures:
      '0': {name: punctuation.section.block.end.bracket.curly.mpro}
    patterns:
    - include: $self

  bracket_block:
    name: meta.block.mpro
    begin: '\['
    end: '\]'
    beginCaptures:
      '0': {name: punctuation.section.block.begin.bracket.square.mpro}
    endCaptures:
      '0': {name: punctuation.section.block.end.bracket.square.mpro}
    patterns:
    - include: $self

  comments:
    - name: comment.block.documentation.mpro
      begin: /\*\*(?!/)
      captures:
        '0': {name: punctuation.definition.comment.mpro}
      end: \*/

    - name: comment.block.mpro
      begin: \/\*
      captures:
        '0': {name: punctuation.definition.comment.mpro}
      end: \*\/

    - name: comment.line.double-slash.mpro
      match: (\/\/).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.mpro}

  constants:
    patterns:
    - name: constant.language.boolean.true.mpro
      match: '\btrue\b'
    - name: constant.language.boolean.false.mpro
      match: '\bfalse\b'
    - name: constant.language.null.mpro
      match: '\bnull\b'
  
  function_builtin:
    patterns:
    - name: support.function.mpro
      match: \b(concat|lookupstr|chr|ord|search|version|version_num|parent_module)\b
    - name: support.function.mpro
      match: \b(children|echo|group|offset|render)\b
    - name: support.function.type-test.mpro
      match: \b(is_undef|is_bool|is_num|is_string|is_list)\b
    - name: support.function.math.mpro
      match: \b(abs|sign|floor|round|ceil|ln|len|log|pow|sqrt|exp|rands|min|max|norm|cross)\b
    - name: support.function.math.trig.mpro
      match: \b(sin|cos|asin|acos|tan|atan|atan2)\b
    - name: support.function.transform.mpro
      match: \b(scale|translate|rotate|multmatrix|color|projection|hull|resize|mirror|minkowski)\b
    - name: support.function.boolean.mpro
      match: \b(union|difference|intersection)\b
    - name: support.function.prim3d.mpro
      match: \b(cube|sphere|cylinder|polyhedron)\b
    - name: support.function.prim2d.mpro
      match: \b(square|circle|polygon|text)\b
    - name: support.function.extrude.mpro
      match: \b(linear_extrude|rotate_extrude)\b

  illegal_names:
    name: invalid.illegal.name.mpro
    match: \b(true|false|module|function|if|else|let)\b

  keyword_arguments:
    comment: Incorporated from PythonImproved grammar
    begin: \b([[:alpha:]_][[:alnum:]_]*)\s*(=)(?!=)
    beginCaptures:
      '1': {name: variable.parameter.function.keyword.mpro}
      '2': {name: keyword.operator.assignment.mpro}
    end: \s*(?:(,)|(?=\)))
    endCaptures:
      '1': {name: punctuation.separator.parameters.mpro}
    patterns:
    - include: $self

  let_keyword:
    name: keyword.control.mpro
    match: '\b(let)\b'

  numbers:
    patterns:
    # Incorporated from PythonImproved grammar
    - comment: Ummm... why do we have three of these? This is one...
      name: constant.numeric.float.mpro
      match: \b(?i:(\d+\.\d*(e[\-\+]?\d+)?))(?=[^[:alpha:]_])

    - comment: This is two...
      name: constant.numeric.float.mpro
      match: (?<=[^[:alnum:]_])(?i:(\.\d+(e[\-\+]?\d+)?))

    - comment: And this is three...
      name: constant.numeric.float.mpro
      match: \b(?i:(\d+e[\-\+]?\d+))

    - name: constant.numeric.integer.decimal.mpro
      match: \b([1-9]+[0-9]*|0)

  operators:
    patterns:
    - name: keyword.operator.assignment.mpro
      match: '=(?!=)'
    - name: keyword.operator.arithmetic.mpro
      match: '\+|-|\*|\/|%|\*\*|\/\/'
    - name: keyword.operator.logical.mpro
      match: '!|&&|\|\|'
    - name: keyword.operator.relational.mpro
      match: '<=|<|==|!=|>=|>'
    - name: keyword.operator.conditional.mpro
      match: '\?|\:'

  paren_block:
    name: meta.block.parens.mpro
    begin: '\('
    end: '\)'
    beginCaptures:
      '0': {name: punctuation.section.parens.begin.bracket.round.mpro}
    endCaptures:
      '0': {name: punctuation.section.parens.end.bracket.round.mpro}
    patterns:
    - include: $self

  string:
    patterns:
    - name: string.quoted.single.mpro
      begin: '\''
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.mpro}
      end: '\''
      endCaptures:
        '0': {name: punctuation.definition.string.end.mpro}
      patterns:
      - name: constant.character.escape.mpro
        match: \\[nt'"]

    - name: string.quoted.double.mpro
      begin: '"'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.mpro}
      end: '"'
      endCaptures:
        '0': {name: punctuation.definition.string.end.mpro}
      patterns:
      - name: constant.character.escape.mpro
        match: \\[nt'"]

